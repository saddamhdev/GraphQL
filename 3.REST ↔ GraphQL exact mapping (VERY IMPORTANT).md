ржжрж╛рж░рзБржг ржкрзНрж░рж╢рзНржи ЁЯСН
**GraphQL-ржП REST API-ржПрж░ ржорждрзЛ different endpoint ржирж╛ ржерж╛ржХрж▓рзЗржУ, conceptually ржПржХржЗ ржХрж╛ржЬ ржХрзАржнрж╛ржмрзЗ рж╣рзЯ**тАФржПржЗржЯрж╛ ржмрзБржЭрзЗ ржЧрзЗрж▓рзЗ GraphQL тАЬclickтАЭ ржХрж░рзЗ ржпрж╛ржмрзЗред

ржЖржорж┐ ржзрж╛ржкрзЗ ржзрж╛ржкрзЗ, REST тЖФ GraphQL mapping ржжрж┐рзЯрзЗ ржмрзБржЭрж╛ржЪрзНржЫрж┐ред

---

## ЁЯза Core truth (ржЖржЧрзЗ ржорж╛ржерж╛рзЯ ржврзБржХрж╛ржУ)

> **GraphQL-ржП URL ржЖрж▓рж╛ржжрж╛ рж╣рзЯ ржирж╛, ржХрж┐ржирзНрждрзБ тАЬoperationтАЭ ржЖрж▓рж╛ржжрж╛ рж╣рзЯ**

REST:

```
/users
/accounts
/loans
```

GraphQL:

```
/graphql   тЖР ржПржХржЯрж╛ржЗ endpoint
```

ЁЯСЙ ржкрж╛рж░рзНржержХрзНржпржЯрж╛ рж╣рзЯ **request body-ржПрж░ ржнрзЗрждрж░рзЗ**

---

## 1я╕ПтГг REST ржП different endpoint ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ?

REST ржП:

```http
GET /users
GET /users/1
POST /users
GET /accounts/1
```

ЁЯСЙ **URL + HTTP method = action**

---

## 2я╕ПтГг GraphQL ржП тАЬdifferent endpointтАЭ ржЖрж╕рж▓рзЗ ржХрзА?

GraphQL ржП:

```http
POST /graphql
```

ржХрж┐ржирзНрждрзБ body ржЖрж▓рж╛ржжрж╛ ЁЯСЗ

### ЁЯФ╣ REST: `/users`

### ЁЯФ╣ GraphQL: `users` (Query field)

```graphql
{
  users {
    id
    name
  }
}
```

---

## 3я╕ПтГг REST тЖФ GraphQL exact mapping (VERY IMPORTANT)

| REST endpoint        | GraphQL equivalent    |
| -------------------- | --------------------- |
| `GET /users`         | `Query.users`         |
| `GET /users/{id}`    | `Query.user(id)`      |
| `POST /users`        | `Mutation.createUser` |
| `GET /accounts/{id}` | `Query.account(id)`   |

ЁЯСЙ **Endpoint ржирж╛ржо тЖТ Query / Mutation field ржирж╛ржо**

---

## 4я╕ПтГг GraphQL schema = REST endpoint list

REST ржП ржпрзЗржоржи controller ржерж╛ржХрзЗ:

```java
@GetMapping("/users")
@GetMapping("/users/{id}")
```

GraphQL ржП рждрзЗржоржиржЗ schema:

```graphql
type Query {
  users: [User]
  user(id: ID): User
}
```

ЁЯУМ Schema ржжрзЗржЦрж▓рзЗржЗ ржмрзЛржЭрж╛ ржпрж╛рзЯ:

* ржХрзА ржХрзА тАЬendpoint-likeтАЭ operation ржЖржЫрзЗ
* ржХрзА data ржкрж╛ржУрзЯрж╛ ржпрж╛ржмрзЗ

---

## 5я╕ПтГг Resolver = REST Controller method

REST:

```java
@GetMapping("/users/{id}")
public User getUser(@PathVariable Long id)
```

GraphQL:

```java
@QueryMapping
public User user(@Argument Long id)
```

ЁЯСЙ ржХрж╛ржЬ ржПржХржЗ
ЁЯСЙ рж╢рзБржзрзБ URL ржирж╛ржЗ

---

## 6я╕ПтГг Postman ржП ржжрзЗржЦрж▓рзЗ ржмрзЛржЭрж╛ ржпрж╛ржмрзЗ

### REST (multiple URLs)

```
GET  /users
GET  /accounts
POST /users
```

### GraphQL (single URL, different body)

```
POST /graphql
```

#### Body #1 (users)

```json
{
  "query": "{ users { id name } }"
}
```

#### Body #2 (user by id)

```json
{
  "query": "{ user(id: 1) { name } }"
}
```

ЁЯСЙ **Body ржмржжрж▓рж╛рж▓рзЗ тАЬendpointтАЭ ржмржжрж▓рж╛рзЯ**

---

## 7я╕ПтГг Real-world analogy (easy to remember)

### REST = ржЖрж▓рж╛ржжрж╛ ржЖрж▓рж╛ржжрж╛ counter

* User counter
* Account counter
* Loan counter

### GraphQL = ржПржХржЯрж╛ржЗ counter

* рждрзБржорж┐ ржмрж▓рзЗ ржжрж╛ржУ:
  ЁЯСЙ тАЬржЖржЬ user + account ржжрзБржЯрзЛржЗ ржЪрж╛ржЗтАЭ

```graphql
{
  user(id: 1) {
    name
    accounts {
      balance
    }
  }
}
```

---

## 8я╕ПтГг Banking / Enterprise perspective

* REST тЖТ many endpoints, versioning pain
* GraphQL тЖТ one endpoint, schema evolves
* Mobile apps тЖТ perfect (low bandwidth)

---

## ЁЯза Interview-ready one-liner

> тАЬGraphQL replaces multiple REST endpoints with a single endpoint, where different queries and mutations act as logical endpoints defined in the schema.тАЭ

ЁЯФе ржПржЗ рж▓рж╛ржЗржиржЯрж╛ ржоржирзЗ рж░рж╛ржЦрзЛ

---

## ЁЯзй Final mental model (gold)

```
REST:
URL decides WHAT happens

GraphQL:
Query decides WHAT happens
```

---

ржЪрж╛ржУ рждрзЛ next ржП ржЖржорж┐ ржжрзЗржЦрж╛рждрзЗ ржкрж╛рж░рж┐ ЁЯСЗ

* **Same feature: REST vs GraphQL side-by-side code**
* **Nested query = multiple REST calls in one GraphQL call**
* **GraphQL pagination & filtering**

ржмрж▓тАФnext ржХрзЛржиржЯрж╛? ЁЯЪА
